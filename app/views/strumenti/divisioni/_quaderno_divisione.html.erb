<%#
  Partial per divisione in colonna (metodo italiano)
  Griglia completa con tutti input navigabili

  Parametri:
    - divisione: oggetto Divisione
    - operation_title / title: titolo opzionale
%>

<style>
  .div-cell {
    width: 100%; height: 100%;
    border: none; outline: none;
    text-align: center;
    font-family: inherit;
    font-weight: bold;
  }
  .div-cell:focus:not(.bg-green-100):not(.bg-red-100):not(.bg-yellow-100) { background: rgba(59, 130, 246, 0.2); }
  .div-cell-lg { font-size: 1.25em; }
  .div-cell-sm { font-size: 1em; }
  .div-cell[readonly] { cursor: default; }
</style>

<%
  cell = "2.5em"

  # Colonne: sinistra (dividendo + 1 per −) | destra (max divisore/quoziente) + 1 colonna vuota
  left_cols = divisione.dividend_length + 1
  right_cols = [divisione.divisor_length, divisione.quotient_length].max
  total_cols = left_cols + right_cols + 1  # +1 per colonna vuota a destra

  steps = divisione.division_steps

  # Prepara gli step per la visualizzazione
  # - Step con q>0: mostrano prodotto e resto
  # - Step con q=0: mostrano solo resto (cifra abbassata senza sottrazione)
  # Salta il primo step se q=0 (non c'è ancora niente da mostrare)
  display_steps = steps.reject.with_index { |s, i| i == 0 && s[:quotient_digit] == 0 }

  # Classi comuni
  cell_border = "border-r border-b border-gray-300 dark:border-gray-600"
  separator_border = "border-l-2 border-l-gray-700 dark:border-l-gray-300"

  # Opzione per mostrare riga header vuota sopra (default: true)
  show_header = if local_assigns.key?(:show_header)
                  local_assigns[:show_header]
                elsif divisione.respond_to?(:show_header)
                  divisione.show_header
                else
                  true
                end

  # Costruisci la mappa delle righe
  rows = []

  # Riga header (opzionale)
  rows << { type: :header } if show_header

  # Riga Dividendo | Divisore
  rows << { type: :dividend_divisor }

  # Righe step - usa display_steps che include anche step con q=0
  first_significant_shown = false
  display_steps.each_with_index do |step, idx|
    is_last_step = (idx == display_steps.length - 1)
    is_significant = step[:quotient_digit] > 0

    if is_significant
      # Step con q>0: mostra prodotto
      if !first_significant_shown
        # Prima riga step significativo: Prodotto | Quoziente
        rows << { type: :product_quotient, step: step, step_idx: idx }
        first_significant_shown = true
      else
        # Righe successive: Prodotto | vuoto
        rows << { type: :product, step: step, step_idx: idx }
      end
    end
    # Step con q=0: NON mostra prodotto, solo la riga resto sotto

    # Riga resto (se c'è bring_down, resto > 0, oppure è l'ultimo step per mostrare resto finale)
    if step[:bring_down] || step[:remainder] > 0 || is_last_step
      rows << { type: :remainder, step: step, step_idx: idx }
    end
  end

  # Riga footer vuota
  rows << { type: :footer }

  # Riga toolbar (se abilitata)
  rows << { type: :toolbar } if divisione.show_toolbar

  # Helper per calcolare il valore di una cella
  def cell_value(row_data, col, left_cols, divisione)
    case row_data[:type]
    when :header, :footer, :toolbar
      { value: nil, type: :empty }

    when :dividend_divisor
      if col < left_cols
        # Lato sinistro: dividendo (allineato a destra)
        padding = left_cols - divisione.dividend_length
        digit_idx = col - padding
        if digit_idx >= 0 && digit_idx < divisione.dividend_length
          { value: divisione.dividend_digits[digit_idx], type: :dividend }
        else
          { value: nil, type: :empty }
        end
      else
        # Lato destro: divisore
        right_col = col - left_cols
        if right_col < divisione.divisor_length
          { value: divisione.divisor_digits[right_col], type: :divisor }
        else
          { value: nil, type: :empty }
        end
      end

    when :product_quotient
      step = row_data[:step]
      product_str = step[:product].to_s
      # Il prodotto si allinea a destra con il partial_dividend che termina alla posizione step_index
      padding = left_cols - divisione.dividend_length
      product_end = padding + step[:step_index] + 1
      product_start = product_end - product_str.length

      if col < left_cols
        # Lato sinistro: prodotto con segno −
        if col == product_start - 1
          { value: '−', type: :minus, readonly: true }
        else
          digit_idx = col - product_start
          if digit_idx >= 0 && digit_idx < product_str.length
            { value: product_str[digit_idx], type: :product, step: row_data[:step_idx] }
          else
            { value: nil, type: :empty }
          end
        end
      else
        # Lato destro: quoziente
        right_col = col - left_cols
        if right_col < divisione.quotient_length
          { value: divisione.quotient_digits[right_col], type: :quotient }
        else
          { value: nil, type: :empty }
        end
      end

    when :product
      step = row_data[:step]
      product_str = step[:product].to_s
      # Il prodotto si allinea a destra con il partial_dividend che termina alla posizione step_index
      padding = left_cols - divisione.dividend_length
      product_end = padding + step[:step_index] + 1
      product_start = product_end - product_str.length

      if col < left_cols
        if col == product_start - 1
          { value: '−', type: :minus, readonly: true }
        else
          digit_idx = col - product_start
          if digit_idx >= 0 && digit_idx < product_str.length
            { value: product_str[digit_idx], type: :product, step: row_data[:step_idx] }
          else
            { value: nil, type: :empty }
          end
        end
      else
        { value: nil, type: :empty }
      end

    when :remainder
      step = row_data[:step]
      remainder_str = step[:remainder].to_s
      # Mostra il resto + la cifra abbassata (se presente)
      bring_down_str = step[:bring_down] || ""
      remainder_with_next = bring_down_str.present? ? remainder_str + bring_down_str : remainder_str
      # Posizione: il resto si allinea a destra con la cifra abbassata (o step_index se non c'è bring_down)
      # padding = left_cols - dividend_length
      # La cifra abbassata è in posizione step_index + 1 (colonna padding + step_index + 1)
      padding = left_cols - divisione.dividend_length
      if bring_down_str.present?
        # bring_down è alla posizione step_index + 1
        remainder_end = padding + step[:step_index] + 2
      else
        # senza bring_down, il resto finisce alla posizione step_index
        remainder_end = padding + step[:step_index] + 1
      end
      remainder_start = remainder_end - remainder_with_next.length

      if col < left_cols
        digit_idx = col - remainder_start
        if digit_idx >= 0 && digit_idx < remainder_with_next.length
          is_bringdown = bring_down_str.present? && digit_idx >= remainder_str.length
          if is_bringdown
            { value: remainder_with_next[digit_idx], type: :bringdown, step: row_data[:step_idx] }
          else
            { value: remainder_with_next[digit_idx], type: :remainder, step: row_data[:step_idx] }
          end
        else
          { value: nil, type: :empty }
        end
      else
        { value: nil, type: :empty }
      end

    else
      { value: nil, type: :empty }
    end
  end
%>

<div class="inline-block" data-controller="quaderno-division">

  <%# Title opzionale %>
  <% title_text = defined?(operation_title) && operation_title.present? ? operation_title :
                  defined?(title) && title.present? ? title : divisione.title %>
  <% if title_text.present? %>
    <div class="font-mono font-bold mb-4 text-gray-700 dark:text-gray-200 bg-gray-100 dark:bg-gray-800 px-4 py-2 rounded inline-block"><%= title_text %></div>
  <% end %>

  <div class="inline-grid border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900"
       style="grid-template-columns: repeat(<%= total_cols %>, <%= cell %>);">

    <% rows.each_with_index do |row_data, row_idx| %>
      <%
        is_header_row = (row_data[:type] == :header)
        is_footer_row = (row_data[:type] == :footer)
        is_toolbar_row = (row_data[:type] == :toolbar)
        is_dividend_row = (row_data[:type] == :dividend_divisor)
        is_product_quotient_row = (row_data[:type] == :product_quotient)
        is_remainder_row = (row_data[:type] == :remainder)

        # Altezza cella (tutte uguali)
        row_height = cell
        cell_class = "div-cell div-cell-lg"

        # Per la linea sopra il resto (sotto il prodotto)
        prev_row = row_idx > 0 ? rows[row_idx - 1] : nil
        prev_step = prev_row && (prev_row[:type] == :product || prev_row[:type] == :product_quotient) ? prev_row[:step] : nil

        # Pulsanti toolbar (partono dalla prima colonna)
        toolbar_buttons = [:clear, :numbers, :steps, :result, :verify]
      %>

      <% total_cols.times do |col| %>
        <%
          cell_data = cell_value(row_data, col, left_cols, divisione)
          is_right_side = (col >= left_cols)
          is_first_right_col = (col == left_cols)
          is_last_col = (col == total_cols - 1)
          is_last_row = (row_idx == rows.length - 1)
          next_row = row_idx < rows.length - 1 ? rows[row_idx + 1] : nil
          next_is_toolbar = next_row && next_row[:type] == :toolbar

          # Classi bordo (evita doppi bordi su ultima colonna e ultima riga)
          border_classes = ""
          border_classes += " border-r border-gray-300 dark:border-gray-600" unless is_last_col
          border_classes += " border-b border-gray-300 dark:border-gray-600" unless is_last_row || next_is_toolbar
          border_classes += " border-t border-gray-300 dark:border-gray-600" if is_toolbar_row
          # Bordo spesso solo nelle righe centrali (non header/footer/toolbar)
          border_classes += " #{separator_border}" if is_first_right_col && !is_header_row && !is_footer_row && !is_toolbar_row

          # Bordo top spesso per quoziente (esclusa ultima colonna vuota)
          if is_product_quotient_row && is_right_side && !is_last_col
            border_classes += " border-t-2 border-t-gray-700 dark:border-t-gray-300"
          end

          # Linea sottrazione sopra il resto
          if is_remainder_row && prev_step && !is_right_side
            product_str = prev_step[:product].to_s
            padding = left_cols - divisione.dividend_length
            product_end = padding + prev_step[:step_index] + 1
            product_start = product_end - product_str.length
            if col >= product_start && col < product_end
              border_classes += " border-t border-t-gray-500 dark:border-t-gray-400"
            end
          end

          # Colori testo
          text_color = case cell_data[:type]
                       when :dividend, :divisor then "text-gray-800 dark:text-gray-100"
                       when :quotient then "text-blue-600 dark:text-blue-400"
                       when :product then "text-red-600 dark:text-red-400"
                       when :remainder then "text-green-600 dark:text-green-400"
                       when :bringdown then "text-gray-500 dark:text-gray-400"
                       when :minus then "text-gray-500 dark:text-gray-400"
                       else "text-gray-800 dark:text-gray-100"
                       end

          # Sfondo per celle risultato (quoziente)
          bg_color = cell_data[:type] == :quotient ? "bg-gray-50 dark:bg-gray-800" : ""

          # Determina se mostrare il valore
          show_value = case cell_data[:type]
                       when :dividend, :divisor then divisione.show_dividend_divisor
                       when :quotient then divisione.show_solution
                       when :product, :remainder, :bringdown then divisione.show_steps
                       when :minus then true
                       else false
                       end

          # Target per Stimulus
          target = case cell_data[:type]
                   when :dividend then "dividend"
                   when :divisor then "divisor"
                   when :quotient then "quotient"
                   when :product then "product"
                   when :remainder then "remainder"
                   when :bringdown then "bringdown"
                   else nil
                   end
        %>

        <div class="<%= border_classes %> <%= bg_color %>" style="height: <%= row_height %>;">
          <% if is_toolbar_row %>
            <%# Toolbar row: renderizza pulsanti tondi centrati nelle celle %>
            <% if col < toolbar_buttons.length %>
              <%
                btn = toolbar_buttons[col]
                btn_config = {
                  clear: { action: "clearGrid", color: "bg-gray-400/40 hover:bg-gray-400/70", icon: "M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16", title: "Cancella" },
                  numbers: { action: "showNumbers", color: "bg-blue-400/40 hover:bg-blue-400/70", icon: "M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z", title: "Mostra Numeri" },
                  steps: { action: "showSteps", color: "bg-orange-400/40 hover:bg-orange-400/70", icon: "M13 5l7 7-7 7M5 5l7 7-7 7", title: "Mostra Passi" },
                  result: { action: "showResult", color: "bg-green-400/40 hover:bg-green-400/70", icon: "M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z", title: "Mostra Risultato" },
                  verify: { action: "verifyAnswers", color: "bg-purple-400/40 hover:bg-purple-400/70", icon: "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4", title: "Verifica" }
                }[btn]
              %>
              <div class="w-full h-full flex items-center justify-center">
                <button type="button"
                        data-action="click->quaderno-division#<%= btn_config[:action] %>"
                        class="w-9 h-9 rounded-full flex items-center justify-center <%= btn_config[:color] %> text-white/80 hover:text-white transition-all print-hidden"
                        title="<%= btn_config[:title] %>">
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="<%= btn_config[:icon] %>" />
                  </svg>
                </button>
              </div>
            <% end %>
          <% else %>
            <input type="text"
                   class="<%= cell_class %> bg-transparent <%= text_color %>"
                   data-row="<%= row_idx %>"
                   data-col="<%= col %>"
                   data-quaderno-division-target="<%= target || 'cell' %>"
                   <% if cell_data[:step] %>data-step="<%= cell_data[:step] %>"<% end %>
                   data-correct-answer="<%= cell_data[:value] || '' %>"
                   maxlength="1"
                   <% if cell_data[:readonly] %>readonly<% end %>
                   <% if show_value && cell_data[:value] %>value="<%= cell_data[:value] %>"<% end %>>
          <% end %>
        </div>
      <% end %>
    <% end %>

  </div>

  <%# Resto finale %>
  <% if divisione.has_remainder? %>
    <div class="mt-2 text-sm text-gray-600 dark:text-gray-400">
      Resto: <span class="font-bold text-orange-600 dark:text-orange-400"><%= divisione.remainder %></span>
    </div>
  <% end %>

</div>
